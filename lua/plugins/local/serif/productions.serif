null;
undefined;
true;
false;
2 + 2;
42 rem 5;
42 rem -5;
-42 rem 5;
-42 rem -5;
Math.sqrt $ 64;
Math.sqrt $ (- 36) $ 100;
Math.sqrt $ Math.abs $ (- 36) $ 0;
64 & Math.sqrt;
100 & (- 36) & Math.sqrt;
0 & (- 36) & Math.abs & Math.sqrt;
1..6;
1..1;
1..0;
"A".."F";
"üçâ".."üçç";
{ let m = 1, n = 5; m..n };
{ let x = {first: 1, last: 5}; x.first..x.last };
([x, y] => x) [1, 2];
([x, y] => y) [1, 2];
([x, y] => x) [];
({x, y} => x) {x: 1, y: 2};
({x, y} => y) {x: 1, y: 2};
({x, y} => x) {};
{ let [x, y] = [1, 2]; x };
{ let [x, y] = [1, 2]; y };
{ let [x, y] = []; x };
{ let {x, y} = {x: 1, y: 2}; x };
{ let {x, y} = {x: 1, y: 2}; y };
{ let {x, y} = {}; x };
Math.sqrt <<< Math.abs $ -64;
(Math.sqrt <<< Math.abs) -64;
(Math.abs >>> Math.sqrt) -64;
0b1000 .<. 2 == 0b100000;
0b1000 .>. 2 == 0b10;
-9 .0>. 2 == 0b00111111111111111111111111111101;
[\%, Math.sqrt] <*> [1, 4, 9];
(+) 2 2;
(-) 3 2;
(+ 2) 2;
(- 2) 3;
(2 +) 2;
(3 -) 2;
equals [1, 2, 3] [1, 2, 3];
[1, 2, 3] == [1, 2, 3];
1 < 2;
1 <= 2;
1 > 2;
1 >= 2;
clamp 0 100 42;
clamp 0 100 -1;
clamp "A" "Z" "~";
Math.sqrt <<< (+ 1) $ 99;
empty String;
empty Array;
empty Object;
typeof invert;
filter (> 1) [1, 2, 3];
filter (> 1) {x: 1, y: 2, z: 3};
reject (> 1) [1, 2, 3];
reject (> 1) {x: 1, y: 2, z: 3};
map Math.sqrt [1, 4, 9];
Math.sqrt <$> [1, 4, 9];
[1, 4, 9] <&> Math.sqrt;
map Math.sqrt {x: 1, y: 4, z: 9};
Math.sqrt <$> {x: 1, y: 4, z: 9};
{x: 1, y: 4, z: 9} <&> Math.sqrt;
map Math.sqrt \(%.length) "Sanctuary";
Math.sqrt <$> \(%.length) $ "Sanctuary";
\(%.length) <&> Math.sqrt $ "Sanctuary";
flip (++) "!" "foo";
flip [Math.floor, Math.ceil] 1.5;
flip {floor: Math.floor, ceil: Math.ceil} 1.5;
typeof bimap;
typeof mapLeft;
ap [Math.sqrt, (^ 2)] [1, 4, 9, 16, 25];
[Math.sqrt, (^ 2)] <*> [1, 4, 9, 16, 25];
ap {a: Math.sqrt, b: (^ 2)} {a: 16, b: 10, c: 1};
{a: Math.sqrt, b: (^ 2)} <*> {a: 16, b: 10, c: 1};
ap \(%1.slice (0, %2)) \(Math.ceil (%.length / 2)) "Haskell";
\(%1.slice (0, %2)) <*> \(Math.ceil (%.length / 2)) $ "Haskell";
lift2 (^) [10] [1, 2, 3];
lift3 \(%1 ++ %3 ++ %2) ["<", "["] [">", "]"] ["foo", "bar", "baz"];
append 3 [1, 2];
prepend 1 [2, 3];
chain \[%, %] [1, 2, 3];
[1, 2, 3] >>= x => [x, x];
[1, 2, 3] >>= \[%, %];
chain (++) toUpper "abcdef";
toUpper >>= (++) $ "abcdef";
[1, 4, 9] >>= Array.of <&> Math.sqrt;  # [1, 4, 9] >>= pure <&> sqrt
[1, 4, 9] <&> Math.sqrt >>= Array.of;  # [1, 4, 9] <&> sqrt >>= pure
join [[1], [2], [3]];
join [[[1, 2, 3]]];
chainRec Array (next => done => s => if s.length == 2 then done <<< (s ++) <$> ["!", "?"] else next <<< (s ++) <$> ["o", "n"]) "";
alt [1, 2, 3] [4, 5, 6];
[1, 2, 3] <|> [4, 5, 6];
zero Array;
zero Object;
reduce (flip prepend) [] [1, 2, 3];
reduce (++) "" {foo: "x", bar: "y", baz: "z"};
size [];
size ["foo", "bar", "baz"];
"c" in ["a", "b", "c"];
"x" in ["a", "b", "c"];
3 in {x: 1, y: 2, z: 3};
8 in {x: 1, y: 2, z: 3};
intercalate ", " [];
intercalate ", " ["foo", "bar", "baz"];
intercalate [0, 0, 0] [];
intercalate [0, 0, 0] [[1], [2, 3], [4, 5, 6], [7, 8], [9]];
reverse [1, 2, 3];
sort ["foo", "bar", "baz"];
sortBy \(%.length) ["red", "green", "blue"];
sortBy \(%.length) ["black", "white"];
sortBy \(%.length) ["white", "black"];
traverse Array \% [[1, 2, 3], [4, 5]];
sequence Array [[1, 2, 3], [4, 5]];
extend \(%.join "") ["x", "y", "z"];
extend ($ [3, 4]) reverse [1, 2];
duplicate [1];
duplicate [1, 2, 3];
duplicate reverse [1, 2] [3, 4];
typeof extract;
contramap \(%.length) Math.sqrt "Sanctuary";
123_456.78;
0b1100_1100;
0o70_70;
0xFF_00;
\% 42;
\%1 42;
\%2 null 42;
\(%1 ++ %2) "foo" "bar";
\(%2 ++ %1) "foo" "bar";
\[%1, %2] "foo" "bar";
\[%2, %1] "foo" "bar";
{ let replace = \(%3.replaceAll (%1, %2)); replace "o" "x" "foo" };
\(%.name) Math.sqrt;
\(%.name) <$> [Math.sin, Math.cos, Math.tan];
map \(%.name) [Math.sin, Math.cos, Math.tan];
{ let üçå = 0; üçå };
"\x0";
"\x2713";
"\x02713";
"\x10ffff";
"\x0027131";
"t \t t";
`""`;
`"`"`;
``"`"`"``;
\% `""`;
\% `"`"`;
\% ``"`"`"``;
Math["sqrt"];
