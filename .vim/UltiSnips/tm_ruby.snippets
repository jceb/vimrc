snippet rb "#!;usr;local;bin;ruby -w"
#!/usr/bin/env ruby${TM_RUBY_SWITCHES: -wKU}

endsnippet

snippet ife "060 ruby if else"
if ${1:condition}
	$2
else
	$3
end
endsnippet

snippet if "070 ruby if"
if ${1:condition}
	$0
end
endsnippet

snippet case "080 ruby case"
case ${1:object}
when ${2:condition}
	$0
end
endsnippet

snippet y ":yields: RDoc comment"
 :yields: ${0:arguments}
endsnippet

snippet # "Add '# =&gt;' Marker"
# => 
endsnippet

snippet Array "Array.new(10) { |i| .. }  (Arr)"
Array.new(${1:10}) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:i}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet bm- "Benchmark_bmbm(__) do __ end"
TESTS = ${1:10_000}
Benchmark.bmbm do |results|
  $0
end
endsnippet

snippet Dir "Dir.glob("..") do |file| .. end  (Dir)"
Dir.glob(${1:"${2:dir/glob/*}"}) { |${3:file}| $0 }
endsnippet

snippet Dir "Dir["__"]"
Dir[${1:"${2:glob/**/*.rb}"}]
endsnippet

snippet File "File.foreach ("..") do |line| .. end  (File)"
File.foreach(${1:"${2:path/to/file}"}) { |${3:line}| $0 }
endsnippet

snippet File "File_open("__") { |file| __ }"
File.open(${1:"${2:path/to/file}"}${3/(^[rwab+]+$)|.*/(?1:, ")/}${3:w}${3/(^[rwab+]+$)|.*/(?1:")/}) { |${4:file}| $0 }
endsnippet

snippet File "File_read("__")"
File.read(${1:"${2:path/to/file}"})
endsnippet

snippet Hash "Hash.new { |hash, key| hash[key] = .. }  (Has)"
Hash.new { |${1:hash}, ${2:key}| ${1:hash}[${2:key}] = $0 }
endsnippet

snippet Md "Marshal.dump(obj, file)  (Md)"
File.open(${1:"${2:path/to/file}.dump"}, "wb") { |${3:file}| Marshal.dump(${4:obj}, ${3:file}) }
endsnippet

snippet Ml "Marshal.load(obj)  (Ml)"
File.open(${1:"${2:path/to/file}.dump"}, "rb") { |${3:file}| Marshal.load(${3:file}) }
endsnippet

snippet Pn- "PStore_new( __ )"
PStore.new(${1:"${2:file_name.pstore}"})
endsnippet

snippet =b "RDoc documentation block"
`[[ $TM_LINE_INDEX != 0 ]] && echo; echo`=begin rdoc
	$0
=end
endsnippet

snippet begin "Wrap in Begin … Rescue … End"
${TM_SELECTED_TEXT/([\t ]*).*/$1/m}begin
	${3:${TM_SELECTED_TEXT/(\A.*)|(.+)|\n\z/(?1:$0:(?2:\t$0))/g}}
${TM_SELECTED_TEXT/([\t ]*).*/$1/m}rescue ${1:Exception}${2/.+/ => /}${2:e}
${TM_SELECTED_TEXT/([\t ]*).*/$1/m}	$0
${TM_SELECTED_TEXT/([\t ]*).*/$1/m}end

endsnippet

snippet Yd- "YAML.dump(.., file)  (Yd-)"
File.open(${1:"${2:path/to/file}.yaml"}, "w") { |${3:file}| YAML.dump(${4:obj}, ${3:file}) }
endsnippet

snippet Yl- "YAML.load(file)  (Yl-)"
File.open(${1:"${2:path/to/file}.yaml"}) { |${3:file}| YAML.load(${3:file}) }
endsnippet

snippet end "__END__"
__END__

endsnippet

snippet am "alias_method ..  (am)"
alias_method :${1:new_name}, :${0:old_name}
endsnippet

snippet all "all? { |e| .. }  (all)"
all? { |${1:e}| $0 }
endsnippet

snippet any "any? { |e| .. }  (any)"
any? { |${1:e}| $0 }
endsnippet

snippet app "application_code ..  (app)"
if __FILE__ == \$PROGRAM_NAME
	$0
end
endsnippet

snippet as "assert(..)  (as)"
assert`snippet_paren.rb`${1:test}, "${0:Failure message.}"`snippet_paren.rb end`
endsnippet

snippet ase "assert_equal"
assert_equal`snippet_paren.rb`${1:expected}, ${0:actual}`snippet_paren.rb end`
endsnippet

snippet asid "assert_in_delta(..)  (asid)"
assert_in_delta`snippet_paren.rb`${1:expected_float}, ${2:actual_float}, ${0:2 ** -20}`snippet_paren.rb end`
endsnippet

snippet asio "assert_instance_of(..)  (asio)"
assert_instance_of`snippet_paren.rb`${1:ExpectedClass}, ${0:actual_instance}`snippet_paren.rb end`
endsnippet

snippet asko "assert_kind_of(..)  (asko)"
assert_kind_of`snippet_paren.rb`${1:ExpectedKind}, ${0:actual_instance}`snippet_paren.rb end`
endsnippet

snippet asm "assert_match(..)  (asm)"
assert_match`snippet_paren.rb`/${1:expected_pattern}/, ${0:actual_string}`snippet_paren.rb end`
endsnippet

snippet asn "assert_nil(..)  (asn)"
assert_nil`snippet_paren.rb`${0:instance}`snippet_paren.rb end`
endsnippet

snippet asnm "assert_no_match(..)  (asnm)"
assert_no_match`snippet_paren.rb`/${1:unexpected_pattern}/, ${0:actual_string}`snippet_paren.rb end`
endsnippet

snippet asne "assert_not_equal(..)  (asne)"
assert_not_equal`snippet_paren.rb`${1:unexpected}, ${0:actual}`snippet_paren.rb end`
endsnippet

snippet asnn "assert_not_nil(..)  (asnn)"
assert_not_nil`snippet_paren.rb`${0:instance}`snippet_paren.rb end`
endsnippet

snippet asns "assert_not_same(..)  (asns)"
assert_not_same`snippet_paren.rb`${1:unexpected}, ${0:actual}`snippet_paren.rb end`
endsnippet

snippet asnr "assert_nothing_raised(..) { .. }  (asnr)"
assert_nothing_raised(${1:Exception}) { $0 }
endsnippet

snippet asnt "assert_nothing_thrown { .. }  (asnt)"
assert_nothing_thrown { $0 }
endsnippet

snippet aso "assert_operator(..)  (aso)"
assert_operator`snippet_paren.rb`${1:left}, :${2:operator}, ${0:right}`snippet_paren.rb end`
endsnippet

snippet asr "assert_raise(..) { .. }  (asr)"
assert_raise(${1:Exception}) { $0 }
endsnippet

snippet asrt "assert_respond_to(..)  (asrt)"
assert_respond_to`snippet_paren.rb`${1:object}, :${0:method}`snippet_paren.rb end`
endsnippet

snippet ass "assert_same(..)  (ass)"
assert_same`snippet_paren.rb`${1:expected}, ${0:actual}`snippet_paren.rb end`
endsnippet

snippet ass "assert_send(..)  (ass)"
assert_send`snippet_paren.rb`[${1:object}, :${2:message}, ${0:args}]`snippet_paren.rb end`
endsnippet

snippet ast "assert_throws(..) { .. }  (ast)"
assert_throws(:${1:expected}) { $0 }
endsnippet

snippet rw "attr_accessor ..  (rw)"
attr_accessor :${0:attr_names}
endsnippet

snippet r "attr_reader ..  (r)"
attr_reader :${0:attr_names}
endsnippet

snippet w "attr_writer ..  (w)"
attr_writer :${0:attr_names}
endsnippet

snippet cla- "class .. &lt; DelegateClass .. initialize .. end  (class)"
class ${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}} < DelegateClass(${2:ParentClass})
	def initialize${3/(^.*?\S.*)|.*/(?1:\()/}${3:args}${3/(^.*?\S.*)|.*/(?1:\))/}
		super(${4:del_obj})
		
		$0
	end
	
	
end
endsnippet

snippet cla "class .. &lt; ParentClass .. initialize .. end"
class ${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}} < ${2:ParentClass}
	def initialize${3/(^.*?\S.*)|.*/(?1:\()/}${3:args}${3/(^.*?\S.*)|.*/(?1:\))/}
		$0
	end
	
	
end
endsnippet

snippet cla "class .. &lt; Struct .. initialize .. end"
${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}} = Struct.new(:${2:attr_names}) do
	def ${3:method_name}
		$0
	end
	
	
end
endsnippet

snippet tc "class .. &lt; Test;;Unit;;TestCase .. end  (tc)"
require "test/unit"

require "${1:library_file_name}"

class Test${2:${1/([\w&&[^_]]+)|./\u$1/g}} < Test::Unit::TestCase
	def test_${3:case_name}
		$0
	end
end
endsnippet

snippet cla "class .. end  (cla)"
class ${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}}
	$0
end
endsnippet

snippet cla "class .. initialize .. end"
class ${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}}
	def initialize${2/(^.*?\S.*)|.*/(?1:\()/}${2:args}${2/(^.*?\S.*)|.*/(?1:\))/}
		$0
	end
	
	
end
endsnippet

snippet cla "class .. instance_methods .. undef .. initialize .. end  (class)"
class ${1:BlankSlate}
	instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
	
	def initialize${2/(^.*?\S.*)|.*/(?1:\()/}${2:args}${2/(^.*?\S.*)|.*/(?1:\))/}
		@${3:delegate} = ${4:delegate_object}
		
		$0
	end
	
	def method_missing(meth, *args, &block)
		@${3:delegate}.send(meth, *args, &block)
	end
	
	
end
endsnippet

snippet cla "class &lt;&lt; self __ end"
class << ${1:self}
	$0
end
endsnippet

snippet clafn "class_from_name()  (clafn)"
split("::").inject(Object) { |par, const| par.const_get(const) }
endsnippet

snippet cl "classify { |e| .. }  (clas)"
classify { |${1:e}| $0 }
endsnippet

snippet col "collect { |e| .. }  (col)"
collect { |${1:e}| $0 }
endsnippet

snippet deec "deep_copy(..)  (dee)"
Marshal.load(Marshal.dump(${0:obj_to_copy}))
endsnippet

snippet def "def end"
def ${1:method_name}
	$0
end
endsnippet

snippet defmm "def method_missing .. end  (mm)"
def method_missing(meth, *args, &blk)
	$0
end
endsnippet

snippet defs "def self .. end  (defs)"
def self.${1:class_method_name}
	$0
end
endsnippet

snippet deft "def test_ .. end  (t)"
def test_${1:case_name}
	$0
end
endsnippet

snippet defd "def_delegator .. (defd)"
def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
endsnippet

snippet defds "def_delegators .. (defds)"
def_delegators :${1:@del_obj}, :${0:del_methods}
endsnippet

snippet deli "delete_if { |e| .. }  (deli)"
delete_if { |${1:e}| $0 }
endsnippet

snippet det "detect { |e| .. }  (det)"
detect { |${1:e}| $0 }
endsnippet

snippet dir "directory()"
File.dirname(__FILE__)
endsnippet

snippet do "do |obj| .. end (doo)"
do${1/(^(?<var>\s*[a-z_][a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1: |)/}${1:variable}${1/(^(?<var>\s*[a-z_][a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}
	$0
end
endsnippet

snippet dow "downto(0) { |n| .. }  (dow)"
downto(${1:0}) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:n}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet ea "each { |e| .. }  (ea)"
each { |${1:e}| $0 }
endsnippet

snippet eab "each_byte { |byte| .. }  (eab)"
each_byte { |${1:byte}| $0 }
endsnippet

snippet eac- "each_char { |chr| .. }  (eac-)"
each_char { |${1:chr}| $0 }
endsnippet

snippet eac- "each_cons(..) { |group| .. }  (eac-)"
each_cons(${1:2}) { |${2:group}| $0 }
endsnippet

snippet eai "each_index { |i| .. }  (eai)"
each_index { |${1:i}| $0 }
endsnippet

snippet eak "each_key { |key| .. }  (eak)"
each_key { |${1:key}| $0 }
endsnippet

snippet eal "each_line { |line| .. }  (eal)"
each_line$1 { |${2:line}| $0 }
endsnippet

snippet eap "each_pair { |name, val| .. }  (eap)"
each_pair { |${1:name}, ${2:val}| $0 }
endsnippet

snippet eas- "each_slice { |group| .. }  (eas)"
each_slice(${1:2}) { |${2:group}| $0 }
endsnippet

snippet eav "each_value { |val| .. }  (eav)"
each_value { |${1:val}| $0 }
endsnippet

snippet eawi "each_with_index { |e, i| .. }  (eawi)"
each_with_index { |${1:e}, ${2:i}| $0 }
endsnippet

snippet elsif "elsif ___"
elsif ${1:condition}
	$0
endsnippet

snippet Forw- "extend Forwardable  (Forw)"
extend Forwardable
endsnippet

snippet fet "fetch(name) { |key| .. }  (fet)"
fetch(${1:name}) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:key}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet fil "fill(range) { |i| .. }  (fil)"
fill(${1:range}) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:i}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet fin "find { |e| .. }  (fin)"
find { |${1:e}| $0 }
endsnippet

snippet fina "find_all { |e| .. }  (fina)"
find_all { |${1:e}| $0 }
endsnippet

snippet flao "flatten_once  (fla)"
inject(Array.new) { |${1:arr}, ${2:a}| ${1:arr}.push(*${2:a}) }
endsnippet

snippet fl "flunk(..)  (fl)"
flunk`snippet_paren.rb`"${0:Failure message.}"`snippet_paren.rb end`
endsnippet

snippet gre "grep(;pattern;) { |match| .. }  (gre)"
grep(${1:/${2:pattern}/}) { |${3:match}| $0 }
endsnippet

snippet gsu "gsub(;..;) { |match| .. }  (gsu)"
gsub(/${1:pattern}/) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:match}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet : "hash pair (:)"
:${1:key} => ${2:"${3:value}"}${4:, }
endsnippet

snippet Comp "include Comparable ..  (Comp)"
include Comparable

def <=>(other)
	$0
end
endsnippet

snippet Enum "include Enumerable ..  (Enum)"
include Enumerable

def each(&block)
	$0
end
endsnippet

snippet inj "inject(init) { |mem, var| .. }  (inj)"
inject${1/.+/(/}${1:init}${1/.+/)/} { |${2:mem}, ${3:var}| $0 }
endsnippet

snippet lam "lambda { |args| .. }  (lam)"
lambda { ${1/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${1:args}${1/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet loo "loop { __ }"
loop { $0 }
endsnippet

snippet map "map { |e| .. }  (map)"
map { |${1:e}| $0 }
endsnippet

snippet mapwi- "map_with_index { |e, i| .. }  (mapwi)"
enum_with_index.map { |${1:e}, ${2:i}| $0 }
endsnippet

snippet max "max { |a, b| .. }  (max)"
max { |a, b| $0 }
endsnippet

snippet min "min { |a, b| .. }  (min)"
min { |a, b| $0 }
endsnippet

snippet mod "module .. ClassMethods .. end"
module ${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}}
	module ClassMethods
		$0
	end
	
	module InstanceMethods
		
	end
	
	def self.included(receiver)
		receiver.extend         ClassMethods
		receiver.send :include, InstanceMethods
	end
end
endsnippet

snippet mod "module .. end"
module ${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}}
	$0
end
endsnippet

snippet mod "module .. module_function .. end"
module ${1:${TM_FILENAME/(?:\A|_)([A-Za-z0-9]+)(?:\.rb)?/(?2::\u$1)/g}}
	module_function
	
	$0
end
endsnippet

snippet nam "namespace :__ do __ end"
namespace :${1:${TM_FILENAME/\.\w+//}} do
	$0
end
endsnippet

snippet { "open yield block ({)"
{ ${1/(^(?<var>\s*[a-z_][a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${1:variable}${1/(^(?<var>\s*[a-z_][a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}${2:$TM_SELECTED_TEXT} 
endsnippet

snippet ope "open("path;or;url", "w") do |doc| .. end (ope)"
open(${1:"${2:path/or/url/or/pipe}"}${3/(^[rwab+]+$)|.*/(?1:, ")/}${3:w}${3/(^[rwab+]+$)|.*/(?1:")/}) { |${4:io}| $0 }
endsnippet

snippet optp "option_parse { .. }  (optp)"
require "optparse"

options = {${1::default => "args"}}

ARGV.options do |opts|
	opts.banner = "Usage:  #{File.basename(\$PROGRAM_NAME)} [OPTIONS]${2/^\s*$|(.*\S.*)/(?1: )/}${2:OTHER_ARGS}"
	
	opts.separator ""
	opts.separator "Specific Options:"
	
	$0
	
	opts.separator "Common Options:"
	
	opts.on( "-h", "--help",
	         "Show this message." ) do
		puts opts
		exit
	end
	
	begin
		opts.parse!
	rescue
		puts opts
		exit
	end
end

endsnippet

snippet par "partition { |e| .. }  (par)"
partition { |${1:e}| $0 }
endsnippet

snippet patfh "path_from_here( __ )"
File.join(File.dirname(__FILE__), *%w[${1:rel path here}])
endsnippet

snippet ran "randomize  (ran)"
sort_by { rand }
endsnippet

snippet rej "reject { |e| .. }  (rej)"
reject { |${1:e}| $0 }
endsnippet

snippet req "require ".."  (req)"
require "$0"
endsnippet

snippet ts "require "tc_.." ..  (ts)"
require "test/unit"

require "tc_${1:test_case_file}"
require "tc_${2:test_case_file}"

endsnippet

snippet reqg- "require_gem "__""
require "$0"
endsnippet

snippet rep "results_report(__) { __ }"
results.report("${1:name}:") { TESTS.times { $0 } }
endsnippet

snippet reve "reverse_each { |e| .. }  (rea)"
reverse_each { |${1:e}| $0 }
endsnippet

snippet sca "scan(;..;) { |match| .. }  (sca)"
scan(/${1:pattern}/) { |${2:match}| $0 }
endsnippet

snippet sel "select { |e| .. }  (sel)"
select { |${1:e}| $0 }
endsnippet

snippet sinc "singleton_class()"
class << self; self end
endsnippet

snippet sor "sort { |a, b| .. }  (sor)"
sort { |a, b| $0 }
endsnippet

snippet sorb "sort_by { |e| .. }  (sorb)"
sort_by { |${1:e}| $0 }
endsnippet

snippet ste "step(2) { |e| .. }  (ste)"
step(${1:2}) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:n}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet sub "sub(;..;) { |match| .. }  (sub)"
sub(/${1:pattern}/) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:match}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet tas "task :task_name =&gt; [:dependent, :tasks] do __ end"
desc "${1:Task description}"
task :${2:${3:task_name} => ${4:[:${5:dependent, :tasks}]}} do
	$0
end
endsnippet

snippet tim "times { |n| .. }  (tim)"
times { ${1/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${1:n}${1/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet tra "transaction( __ ) do __ end"
transaction${1/(^.*?\S.*)|.*/(?1:\()/}${1:true}${1/(^.*?\S.*)|.*/(?1:\))/} { $0 }
endsnippet

snippet unif "unix_filter .. (uni)"
ARGF.each_line$1 do |${2:line}|
	$0
end
endsnippet

snippet unless "unless (unless)"
unless ${1:condition}
	$0
end
endsnippet

snippet until "until ___ end"
until ${1:condition}
	$0
end
endsnippet

snippet opt "untitled"
opts.on( "-${1:o}", "--${2:long-option-name}"${3/^\s*$|(.*\S.*)/(?1:, )/}${3:String},
         "${4:Option description.}" ) do |${6:opt}|
	$0
end
endsnippet

snippet upt "upto(1.0;0.0) { |n| .. }  (upt)"
upto(${1:1.0/0.0}) { ${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}${2:n}${2/(^(?<var>\s*(?:\*|\*?[a-z_])[a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:| )/}$0 }
endsnippet

snippet usai "usage_if()  (usai)"
if ARGV.$1
	abort "Usage:  #{\$PROGRAM_NAME} ${2:ARGS_GO_HERE}"
end
endsnippet

snippet usau "usage_unless()  (usau)"
unless ARGV.$1
	abort "Usage:  #{\$PROGRAM_NAME} ${2:ARGS_GO_HERE}"
end
endsnippet

snippet when "when"
when ${1:condition}
	$0
endsnippet

snippet while "while ___ end"
while ${1:condition}
	$0
end
endsnippet

snippet xml- "xmlread(__)"
REXML::Document.new(File.read(${1:"${2:path/to/file}"}))
endsnippet

snippet xpa "xpath(__) { __ }"
elements.each(${1:"${2://XPath}"}) do |${3:node}|
	$0
end
endsnippet

snippet zip "zip(enums) { |row| .. }  (zip)"
zip(${1:enums}) { |${2:row}| $0 }
endsnippet

