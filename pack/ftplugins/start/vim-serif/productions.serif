null;
undefined;
true;
false;
2 + 2;
42 rem 5;
42 rem -5;
-42 rem 5;
-42 rem -5;
Math.sqrt $ 64;
Math.sqrt $ (- 36) $ 100;
Math.sqrt $ Math.abs $ (- 36) $ 0;
64 & Math.sqrt;
100 & (- 36) & Math.sqrt;
0 & (- 36) & Math.abs & Math.sqrt;
match 1 when 1 then "one" when 2 then "two" when 3 then "three";
match 2 when 1 then "one" when 2 then "two" when 3 then "three";
match 3 when 1 then "one" when 2 then "two" when 3 then "three";
match "foo" when "foo" then 1 when "bar" then 2 when "baz" then 3;
match "bar" when "foo" then 1 when "bar" then 2 when "baz" then 3;
match "baz" when "foo" then 1 when "bar" then 2 when "baz" then 3;
match 0 when x then x;
match 0 when x = 0 then x;
match [] when [] then 0;
match [1] when [] then 0 when [1] then 1;
match [1, 2] when [] then 0 when [1] then 1 when [1, 2] then 2;
match [1, 2] when [] then 0 when [1] then 1 when [x, y] then "x: \(x), y: \(y)";
match [] when [...] then 0;
match [1] when [] then 0 when [...] then 1;
match [1] when [x, ...] then 0 when [...] then 1;
match ["foo", "bar"] when array = [first, ...] then {array, first};
match {} when {} then 0;
match {x: 1} when {x: 1} then 0;
match {x: 1, y: 2} when {x: 1, y: 2} then 0;
match {x: 1, y: 2, z: 3} when {x: 1, y: 2} then 0;
match {x: 1, y: 2, z: 3} when {x: 1, y: 2, z} then z;
match {bar: {baz: "quux"}} when foo = {bar: bar = {baz}} then {foo, bar, baz};
match [1] when [x] if x > 0 then "\(x) is positive" when [x] then "\(x) is not positive";
match [0] when [x] if x > 0 then "\(x) is positive" when [x] then "\(x) is not positive";
match "bar" when ["b", x, y] then {x, y};
match 0 when x then x;
1..6;
1..1;
1..0;
"A".."F";
"üçâ".."üçç";
{ let m = 1, n = 5; m..n };
{ let x = {first: 1, last: 5}; x.first..x.last };
([x, y] => x) [1, 2];
([x, y] => y) [1, 2];
([x, y] => x) [];
({x, y} => x) {x: 1, y: 2};
({x, y} => y) {x: 1, y: 2};
({x, y} => x) {};
{ let [x, y] = [1, 2]; x };
{ let [x, y] = [1, 2]; y };
{ let [x, y] = []; x };
{ let {x, y} = {x: 1, y: 2}; x };
{ let {x, y} = {x: 1, y: 2}; y };
{ let {x, y} = {}; x };
Math.sqrt <<< Math.abs $ 36 - 100;
0b1000 .<. 2 == 0b100000;
0b1000 .>. 2 == 0b10;
-9 .0>. 2 == 0b00111111111111111111111111111101;
[\%, Math.sqrt] <*> [1, 4, 9];
(+) 2 2;
(-) 3 2;
(+ 2) 2;
(- 2) 3;
(2 +) 2;
(3 -) 2;
equals [1, 2, 3] [1, 2, 3];
[1, 2, 3] == [1, 2, 3];
1 < 2;
1 <= 2;
1 > 2;
1 >= 2;
min 10 2;
min "10" "2";
max 10 2;
max "10" "2";
clamp 0 100 42;
clamp 0 100 -1;
clamp "A" "Z" "~";
compose Math.sqrt (+ 1) 99;
Math.sqrt <<< (+ 1) $ 99;
concat "abc" "def";
"abc" <> "def";
concat [1, 2, 3] [4, 5, 6];
[1, 2, 3] <> [4, 5, 6];
concat {x: 1, y: 2} {y: 3, z: 4};
{x: 1, y: 2} <> {y: 3, z: 4};
empty String;
empty Array;
empty Object;
typeof invert;
filter (> 1) [1, 2, 3];
filter (> 1) {x: 1, y: 2, z: 3};
reject (> 1) [1, 2, 3];
reject (> 1) {x: 1, y: 2, z: 3};
map Math.sqrt [1, 4, 9];
Math.sqrt <$> [1, 4, 9];
[1, 4, 9] <&> Math.sqrt;
map Math.sqrt {x: 1, y: 4, z: 9};
Math.sqrt <$> {x: 1, y: 4, z: 9};
{x: 1, y: 4, z: 9} <&> Math.sqrt;
map Math.sqrt \(%.length) "Sanctuary";
Math.sqrt <$> \(%.length) $ "Sanctuary";
\(%.length) <&> Math.sqrt $ "Sanctuary";
flip (<>) "!" "foo";
flip [Math.floor, Math.ceil] 1.5;
flip {floor: Math.floor, ceil: Math.ceil} 1.5;
typeof bimap;
typeof mapLeft;
ap [Math.sqrt, (^ 2)] [1, 4, 9, 16, 25];
[Math.sqrt, (^ 2)] <*> [1, 4, 9, 16, 25];
ap {a: Math.sqrt, b: (^ 2)} {a: 16, b: 10, c: 1};
{a: Math.sqrt, b: (^ 2)} <*> {a: 16, b: 10, c: 1};
ap \(%1.slice (0, %2)) \(Math.ceil (%.length / 2)) "Haskell";
\(%1.slice (0, %2)) <*> \(Math.ceil (%.length / 2)) $ "Haskell";
lift2 (^) [10] [1, 2, 3];
lift3 \(%1 <> %3 <> %2) ["<", "["] [">", "]"] ["foo", "bar", "baz"];
apFirst [1, 2] [3, 4];
[1, 2] <* [3, 4];
apSecond [1, 2] [3, 4];
[1, 2] *> [3, 4];
of Array 42;
of Function 42 null;
append 3 [1, 2];
prepend 1 [2, 3];
chain \[%, %] [1, 2, 3];
[1, 2, 3] >>= x => [x, x];
[1, 2, 3] >>= \[%, %];
chain (<>) toUpper "abcdef";
toUpper >>= (<>) $ "abcdef";
[1, 4, 9] >>= Array.of <&> Math.sqrt;  # [1, 4, 9] >>= pure <&> sqrt
[1, 4, 9] <&> Math.sqrt >>= Array.of;  # [1, 4, 9] <&> sqrt >>= pure
join [[1], [2], [3]];
join [[[1, 2, 3]]];
chainRec Array (next => done => s => if s.length == 2 then done <<< (s <>) <$> ["!", "?"] else next <<< (s <>) <$> ["o", "n"]) "";
alt [1, 2, 3] [4, 5, 6];
[1, 2, 3] <|> [4, 5, 6];
zero Array;
zero Object;
reduce (flip prepend) [] [1, 2, 3];
reduce (<>) "" {foo: "x", bar: "y", baz: "z"};
size [];
size ["foo", "bar", "baz"];
all Number.isInteger [];
all Number.isInteger [1, 2, 3];
all Number.isInteger [0, 0.25, 0.5, 0.75, 1];
any Number.isInteger [];
any Number.isInteger [1, 2, 3];
any Number.isInteger [0, 0.25, 0.5, 0.75, 1];
none Number.isInteger [];
none Number.isInteger [0, 0.25, 0.5, 0.75, 1];
"c" in ["a", "b", "c"];
"x" in ["a", "b", "c"];
3 in {x: 1, y: 2, z: 3};
8 in {x: 1, y: 2, z: 3};
intercalate ", " [];
intercalate ", " ["foo", "bar", "baz"];
intercalate [0, 0, 0] [];
intercalate [0, 0, 0] [[1], [2, 3], [4, 5, 6], [7, 8], [9]];
foldMap String \(%.name) [Math.sin, Math.cos, Math.tan];
reverse [1, 2, 3];
sort ["foo", "bar", "baz"];
sortBy \(%.length) ["red", "green", "blue"];
sortBy \(%.length) ["black", "white"];
sortBy \(%.length) ["white", "black"];
traverse Array \% [[1, 2, 3], [4, 5]];
sequence Array [[1, 2, 3], [4, 5]];
extend \(%.join "") ["x", "y", "z"];
extend ($ [3, 4]) reverse [1, 2];
duplicate [1];
duplicate [1, 2, 3];
duplicate reverse [1, 2] [3, 4];
typeof extract;
contramap \(%.length) Math.sqrt "Sanctuary";
123_456.78;
0b1100_1100;
0o70_70;
0xFF_00;
\% 42;
\%1 42;
\%2 null 42;
\(%1 <> %2) "foo" "bar";
\(%2 <> %1) "foo" "bar";
\[%1, %2] "foo" "bar";
\[%2, %1] "foo" "bar";
{ let replace = \(%3.replaceAll (%1, %2)); replace "o" "x" "foo" };
\(%.name) Math.sqrt;
\(%.name) <$> [Math.sin, Math.cos, Math.tan];
map \(%.name) [Math.sin, Math.cos, Math.tan];
{ let üçå = 0; üçå };
"\x0";
"\x2713";
"\x02713";
"\x10ffff";
"\x0027131";
"t \t t";
`""`;
`"`"`;
``"`"`"``;
\% `""`;
\% `"`"`;
\% ``"`"`"``;
Math["sqrt"];
"before \(`""`) after";
"before \(`"`"`) after";
"before \(``"`"`"``) after";
"before \(\% `""`) after";
"before \(\% `"`"`) after";
"before \(\% ``"`"`"``) after";
"before \(null) after";
"before \(undefined) after";
"before \(true) after";
"before \(false) after";
"before \(
  2 + 2  # should evaluate to 4
) after";
